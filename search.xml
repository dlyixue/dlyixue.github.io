<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Crypto++ 使用</title>
      <link href="/2024/03/09/Crypto-%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/09/Crypto-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h1 id="常用密码学原语的C-代码使用"><a href="#常用密码学原语的C-代码使用" class="headerlink" title="常用密码学原语的C++代码使用"></a>常用密码学原语的C++代码使用</h1><hr><h2 id="1-Crypto-部署与测试"><a href="#1-Crypto-部署与测试" class="headerlink" title="1. Crypto++部署与测试"></a>1. Crypto++部署与测试</h2><h3 id="Crypto-部署"><a href="#Crypto-部署" class="headerlink" title="Crypto++部署"></a>Crypto++部署</h3><p>本文采用Windows子系统wsl2进行部署测试</p><ul><li>从官网下载Crypto++ (<a href="https://www.cryptopp.com/">https://www.cryptopp.com/</a>)</li><li><code>make -j4</code></li><li><code>make install PREFIX=./path</code> 使用path指定安装路径</li><li><code>g++ hw1.cpp -I /usr/local/bin/include/cryptopp -o hw1.exe /usr/local/bin/lib/libcryptopp.a</code> 使用g++进行编译</li></ul><h3 id="Crypto-测试"><a href="#Crypto-测试" class="headerlink" title="Crypto++测试"></a>Crypto++测试</h3><ul><li>使用SHA384进行测试</li><li>这里利用StringSource的方法进行函数调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用SHA384进行加密</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encryptSHA384</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string cipher, encoded;</span><br><span class="line">    SHA384 hash;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HashFilter(hash, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> HexEncoder( </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">new</span> StringSink( cipher ) ) ) )</span></span>; <span class="comment">// HashFilter</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(SHA384) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    string in_string = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    CryptoPP::byte key[AES::DEFAULT_KEYLENGTH] = <span class="string">&quot;abcd1234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original text is: &quot;</span> &lt;&lt; in_string &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key is: &quot;</span> &lt;&lt; key &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用SHA384进行加密</span></span><br><span class="line">    <span class="built_in">encryptSHA384</span>(in_string);</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/password_hw1/Untitled.png" alt="img"></p><h2 id="Crypto-使用"><a href="#Crypto-使用" class="headerlink" title="Crypto++使用"></a>Crypto++使用</h2><h3 id="字符串、二进制、十六进制相互转换"><a href="#字符串、二进制、十六进制相互转换" class="headerlink" title="字符串、二进制、十六进制相互转换"></a>字符串、二进制、十六进制相互转换</h3><ul><li>任务比较简单，两两转换共需要<strong>6</strong>个函数，这里我们采用环形转换的方式，即字符串转二进制、二进制转十六进制、十六进制转字符串，这样即可说明可以互相转化，我们实现<strong>3</strong>个函数即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转2进制</span></span><br><span class="line"><span class="function">string <span class="title">string_to_bit</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string encoded = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: plain)&#123;</span><br><span class="line">        <span class="function">bitset&lt;8&gt; <span class="title">bs</span><span class="params">(c)</span></span>;</span><br><span class="line">        encoded += bs.<span class="built_in">to_string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary Encoder text is: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2进制转16进制</span></span><br><span class="line"><span class="function">string <span class="title">bit_to_hex</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string encoded;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; plain.<span class="built_in">length</span>(); i += <span class="number">8</span>)&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        string ts;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; <span class="built_in">stoi</span>(plain.<span class="built_in">substr</span>(i, <span class="number">8</span>), <span class="literal">nullptr</span>, <span class="number">2</span>);</span><br><span class="line">        ss &gt;&gt; ts;    </span><br><span class="line">        <span class="built_in">transform</span>(ts.<span class="built_in">begin</span>(), ts.<span class="built_in">end</span>(), ts.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        encoded += ts;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hex Encoder text is: &quot;</span> &lt;&lt; encoded &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制转字符串</span></span><br><span class="line"><span class="function">string <span class="title">hex_to_string</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string encoded;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss2</span><span class="params">( plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HexDecoder(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink( encoded )</span></span></span><br><span class="line"><span class="params"><span class="function">        ) <span class="comment">// HexDecoder</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>; <span class="comment">// StringSource</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String text is: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 进制转换</span></span><br><span class="line">    string bits,hexs,strs;</span><br><span class="line">    bits = <span class="built_in">string_to_bit</span>(in_string);</span><br><span class="line">    hexs = <span class="built_in">bit_to_hex</span>(bits);</span><br><span class="line">    strs = <span class="built_in">hex_to_string</span>(hexs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/password_hw1/Untitled%201.png" alt="img"></p><ul><li>通过转换我们可以发现，最后结果和初始输入相同</li></ul><h3 id="哈希：Sha1哈希、MD5哈希、Sha256哈希"><a href="#哈希：Sha1哈希、MD5哈希、Sha256哈希" class="headerlink" title="哈希：Sha1哈希、MD5哈希、Sha256哈希"></a>哈希：Sha1哈希、MD5哈希、Sha256哈希</h3><ul><li>使用Crypto中的哈希类实现</li><li>几类哈希方法使用方法类似，这里使用StringSource的方法，以十六进制输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sha1哈希加密</span></span><br><span class="line"><span class="function">string <span class="title">encryptSHA1</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string cipher, encoded;</span><br><span class="line">    SHA1 hash;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HashFilter(hash, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> HexEncoder( </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">new</span> StringSink( cipher ) ) ) )</span></span>; <span class="comment">// HashFilter</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(SHA1) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MD5哈希</span></span><br><span class="line"><span class="function">string <span class="title">encryptMD5</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string cipher, encoded;</span><br><span class="line">    MD5 hash;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HashFilter(hash, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> HexEncoder( </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">new</span> StringSink( cipher ) ) ) )</span></span>; <span class="comment">// HashFilter</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(MD5) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256哈希</span></span><br><span class="line"><span class="function">string <span class="title">encryptSHA256</span><span class="params">(string&amp; plain)</span></span>&#123;</span><br><span class="line">    std::string cipher, encoded;</span><br><span class="line">    SHA256 hash;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HashFilter(hash, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> HexEncoder( </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">new</span> StringSink( cipher ) ) ) )</span></span>; <span class="comment">// HashFilter</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(SHA256) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Sha1哈希</span></span><br><span class="line">    <span class="built_in">encryptSHA1</span>(in_string);</span><br><span class="line">    <span class="comment">// MD5哈希</span></span><br><span class="line">    <span class="built_in">encryptMD5</span>(in_string);</span><br><span class="line">    <span class="comment">// Sha256哈希</span></span><br><span class="line">    <span class="built_in">encryptSHA256</span>(in_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/password_hw1/Untitled%202.png" alt="img"></p><h3 id="对称加密、解密：AES、DES"><a href="#对称加密、解密：AES、DES" class="headerlink" title="对称加密、解密：AES、DES"></a>对称加密、解密：AES、DES</h3><ul><li>采用ECB的模式构造AES、DES</li><li>密钥为“abcd1234”，长度分别为16、8</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AES加密</span></span><br><span class="line"><span class="function">string <span class="title">encryptAES</span><span class="params">(string&amp; plain, CryptoPP::byte* key)</span></span>&#123;</span><br><span class="line">    std::string cipher, encoded;</span><br><span class="line">    ECB_Mode&lt;AES&gt;::Encryption e;</span><br><span class="line">    e.<span class="built_in">SetKey</span>(key, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// The StreamTransformationFilter removes</span></span><br><span class="line">    <span class="comment">//  padding as required.</span></span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> StreamTransformationFilter(e,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink(cipher)) <span class="comment">// StreamTransformationFilter</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(AES) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">StringSource <span class="title">ss2</span><span class="params">( cipher, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HexEncoder(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink( encoded )</span></span></span><br><span class="line"><span class="params"><span class="function">        ) <span class="comment">// HexDecoder</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(AES) The hex text is: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decryptAES</span><span class="params">(string&amp; cipher, CryptoPP::byte* key)</span></span>&#123;</span><br><span class="line">    std::string recovered;</span><br><span class="line">    ECB_Mode&lt;AES&gt;::Decryption d;</span><br><span class="line">    d.<span class="built_in">SetKey</span>(key, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// The StreamTransformationFilter removes</span></span><br><span class="line">    <span class="comment">//  padding as required.</span></span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(cipher, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> StreamTransformationFilter(d,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink(recovered)) <span class="comment">// StreamTransformationFilter</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(AES) The recovered text is: &quot;</span> &lt;&lt; recovered &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> recovered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DES加密</span></span><br><span class="line"><span class="function">string <span class="title">encryptDES</span><span class="params">(string&amp; plain, CryptoPP::byte* key)</span></span>&#123;</span><br><span class="line">    string cipher, encoded;</span><br><span class="line">    ECB_Mode&lt;DES&gt;::Encryption e;</span><br><span class="line">    e.<span class="built_in">SetKey</span>(key, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// The StreamTransformationFilter removes</span></span><br><span class="line">    <span class="comment">//  padding as required.</span></span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> StreamTransformationFilter(e,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink(cipher)) <span class="comment">// StreamTransformationFilter</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(DES) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">StringSource <span class="title">ss2</span><span class="params">( cipher, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HexEncoder(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink( encoded )</span></span></span><br><span class="line"><span class="params"><span class="function">        ) <span class="comment">// HexDecoder</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(DES) The hex text is: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decryptDES</span><span class="params">(string&amp; cipher, CryptoPP::byte* key)</span></span>&#123;</span><br><span class="line">    std::string recovered;</span><br><span class="line">    ECB_Mode&lt;DES&gt;::Decryption d;</span><br><span class="line">    d.<span class="built_in">SetKey</span>(key, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// The StreamTransformationFilter removes</span></span><br><span class="line">    <span class="comment">//  padding as required.</span></span><br><span class="line">    <span class="function">StringSource <span class="title">ss1</span><span class="params">(cipher, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> StreamTransformationFilter(d,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> StringSink(recovered)) <span class="comment">// StreamTransformationFilter</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(DES) The recovered text is: &quot;</span> &lt;&lt; recovered &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> recovered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/password_hw1/Untitled%203.png" alt="img"></p><h3 id="RSA非对称加密：秘钥对生成、加密、解密、签名"><a href="#RSA非对称加密：秘钥对生成、加密、解密、签名" class="headerlink" title="RSA非对称加密：秘钥对生成、加密、解密、签名"></a>RSA非对称加密：秘钥对生成、加密、解密、签名</h3><ul><li>秘钥对生成</li><li>key_size为2048位</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成密钥</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> key_size, RSA::PrivateKey&amp; private_key, RSA::PublicKey&amp; public_key)</span><span class="comment">//钥匙的长度，通常是2048以上，越大相对越安全，但相对的运算越久</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AutoSeededRandomPool rng;<span class="comment">//伪随机数</span></span><br><span class="line">InvertibleRSAFunction params;</span><br><span class="line">params.<span class="built_in">GenerateRandomWithKeySize</span>(rng, key_size);</span><br><span class="line"><span class="function">RSA::PrivateKey <span class="title">privateKey</span><span class="params">(params)</span></span>;</span><br><span class="line">  <span class="function">RSA::PublicKey <span class="title">publicKey</span><span class="params">(params)</span></span>;</span><br><span class="line">  private_key = privateKey;</span><br><span class="line">  public_key = publicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加密</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RSA加密</span></span><br><span class="line"><span class="function">string <span class="title">encryptRSA</span><span class="params">(string&amp; plain, RSA::PublicKey&amp; public_key)</span></span>&#123;</span><br><span class="line">    string cipher,encoded;</span><br><span class="line">    AutoSeededRandomPool rng;</span><br><span class="line">    <span class="function"><span class="type">const</span>  RSAES_OAEP_SHA_Encryptor <span class="title">encrypt</span><span class="params">(public_key)</span></span>;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss_1</span><span class="params">(plain, <span class="literal">true</span>, <span class="keyword">new</span> </span></span></span><br><span class="line"><span class="params"><span class="function">        PK_EncryptorFilter(rng, encrypt, <span class="keyword">new</span>  StringSink(cipher)))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) The cipher text is: &quot;</span> &lt;&lt; cipher &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">StringSource <span class="title">ss_2</span><span class="params">(cipher, <span class="literal">true</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HexEncoder(<span class="keyword">new</span> StringSink(encoded)))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) The encoded text is: &quot;</span> &lt;&lt; encoded &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解密</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RSA解密</span></span><br><span class="line"><span class="function">string <span class="title">decryptRSA</span><span class="params">(string&amp; cipher, RSA::PrivateKey&amp; private_key)</span></span>&#123;</span><br><span class="line">    string recovered;</span><br><span class="line">    AutoSeededRandomPool rng;</span><br><span class="line">    <span class="function">RSAES_OAEP_SHA_Decryptor <span class="title">d</span><span class="params">(private_key)</span></span>;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss2</span><span class="params">(cipher, <span class="literal">true</span>, <span class="keyword">new</span> </span></span></span><br><span class="line"><span class="params"><span class="function">        PK_DecryptorFilter(rng, d, <span class="keyword">new</span> StringSink(recovered)))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) The recovered text is: &quot;</span> &lt;&lt; recovered &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> recovered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>签名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RSA签名</span></span><br><span class="line"><span class="function">string <span class="title">signatureRSA</span><span class="params">(string&amp; plain, RSA::PrivateKey&amp; private_key)</span></span>&#123;</span><br><span class="line">    string signature, encoded;</span><br><span class="line">    AutoSeededRandomPool rng;</span><br><span class="line">    <span class="type">const</span>  RSASS&lt;PSS, SHA256&gt;::<span class="function">Signer <span class="title">signer</span><span class="params">(private_key)</span></span>;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss</span><span class="params">(plain, <span class="literal">true</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> SignerFilter(rng, signer, <span class="keyword">new</span> StringSink(signature)))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) The signature is: &quot;</span> &lt;&lt; signature &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">StringSource <span class="title">ss2</span><span class="params">(signature, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> HexEncoder(<span class="keyword">new</span> StringSink(encoded)))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) The encoded signature is: &quot;</span> &lt;&lt; encoded &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证</li><li>验证同时需要明文和签名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RSA验证</span></span><br><span class="line"><span class="function">string <span class="title">verifyRSA</span><span class="params">(string&amp; signature, RSA::PublicKey&amp; public_key)</span></span>&#123;</span><br><span class="line">    string recovered;</span><br><span class="line">    <span class="type">const</span> RSASS&lt;PSS, SHA256&gt;::<span class="function">Verifier <span class="title">verifier</span><span class="params">(public_key)</span></span>;</span><br><span class="line">    <span class="function">StringSource <span class="title">ss</span><span class="params">(signature, <span class="literal">true</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> SignatureVerificationFilter(verifier, <span class="keyword">new</span> StringSink(recovered),</span></span></span><br><span class="line"><span class="params"><span class="function">            SignatureVerificationFilter::THROW_EXCEPTION))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(RSA) Verified signature on message&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> recovered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// RSA</span></span><br><span class="line">    RSA::PrivateKey private_key;</span><br><span class="line">RSA::PublicKey public_key;</span><br><span class="line">    string cipher,sign,recovered,plain_cipher;</span><br><span class="line">    <span class="built_in">generate_key</span>(<span class="number">2048</span>, private_key, public_key);</span><br><span class="line">    cipher = <span class="built_in">encryptRSA</span>(in_string, public_key);</span><br><span class="line">    <span class="built_in">decryptRSA</span>(cipher, private_key);</span><br><span class="line">    sign = <span class="built_in">signatureRSA</span>(in_string, private_key);</span><br><span class="line">    plain_cipher = in_string + sign;</span><br><span class="line">    <span class="built_in">verifyRSA</span>(plain_cipher, public_key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/password_hw1/Untitled%204.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>利用Crypto++方法库，学习使用了主要的加解密算法</li><li>代码和实验结果另附文件</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滤波类状态估计方法</title>
      <link href="/2023/11/12/%E6%BB%A4%E6%B3%A2%E7%B1%BB%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/12/%E6%BB%A4%E6%B3%A2%E7%B1%BB%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="滤波类状态估计方法"><a href="#滤波类状态估计方法" class="headerlink" title="滤波类状态估计方法"></a>滤波类状态估计方法</h1><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-现实中位置描述"><a href="#1-1-现实中位置描述" class="headerlink" title="1.1 现实中位置描述"></a>1.1 现实中位置描述</h2><p>在生活中，我们经常需要描述位置信息。回顾我们的日常习惯，我们通常使用两种方法来描述位置：</p><ul><li>一种是使用定位软件，如百度地图、卫星定位系统、甚至古代的指南针等等，它们会给我们一个精确信息，告知我们身处何处，距离目标有多少米，将位置精确为一个点。</li><li>然而，通常当我们向他人描述位置的时候，我们很少借助定位，而是会描述目标的粗略方位（如东西南北等），和我们的距离（大概二三百米），这样目标的位置则不是一个精确的点，而是一个环形的区域目标可能在这个区域任何一个地方出现，也就说位置信息变成了一个等可能概率模型。这便是概率状态估计的现实意义。</li></ul><p><img src="/pic/state/Untitled.jpeg" alt="img"></p><h2 id="1-2-概率状态估计"><a href="#1-2-概率状态估计" class="headerlink" title="1.2 概率状态估计"></a>1.2 概率状态估计</h2><p>很多时候，我们描述一个物体的时候，它其实并不是物理意义上的一个质点，是一个有体积的实物，也就说质点是物体一个抽象，它将物体信息集中到一个点中。相反，我们也可以将这个点进行放大，那么其实这个物体只是说在这个点附近出现的可能性最高，它的信息分散在概率之中。</p><p>类似二维高斯分布和热力图，在点附近的概率和热力度最高，离点越远概率和热力越低。同时，当我们对位置描述的越精准，高斯分布的方差也就越小，变得更加集中，热力图的热量则更会集中在一个区域，其他区域热度更小。</p><p><img src="/pic/state/Untitled.png" alt="img"></p><p>这样其实所有的位置或是状态，就可以使用概率模型来进行描述，那么我们对位置或状态的估计就变成了对概率的估计。</p><h1 id="2-概率知识"><a href="#2-概率知识" class="headerlink" title="2. 概率知识"></a>2. 概率知识</h1><ul><li>我们将简要介绍一些基础的概率知识。</li><li>熟悉的读者可以跳过这一部分</li></ul><h2 id="2-1-离散概率分布"><a href="#2-1-离散概率分布" class="headerlink" title="2.1 离散概率分布"></a>2.1 离散概率分布</h2><ul><li>X 是一个随机变量</li><li>X 取值在一个可数的集合之中$\{x_1,x_2,…,x_n\}$</li><li>$P(X=X_i)orP(X_i)$则表示X取$X_i$的概率</li><li>$P(\cdot)$ 则表示概率质量函数，即其所有可能的概率取值</li></ul><script type="math/tex; mode=display">P(Room)=<0.7,0.2,0.08,0.02></script><h2 id="2-2-连续概率分布"><a href="#2-2-连续概率分布" class="headerlink" title="2.2 连续概率分布"></a>2.2 连续概率分布</h2><ul><li>X 是一个连续变量</li><li>$P(X=x),or P(x)$，表示概率密度函数</li></ul><script type="math/tex; mode=display">Pr(x\in(a,b)) = \int_{a}^{b}p(x)dx</script><p><img src="/pic/state/Untitled1.png" alt="img"></p><h2 id="2-3-条件概率"><a href="#2-3-条件概率" class="headerlink" title="2.3 条件概率"></a>2.3 条件概率</h2><ul><li>设A，B为两个事件且$P(A)&gt;0$，则$P(B|A)=\frac{P(AB)}{P(A)}$，为事件A发生下事件B发生的条件概率</li><li>根据这个我们有 $P(AB)=P(B|A)*P(A)$</li></ul><h2 id="2-4-概率和"><a href="#2-4-概率和" class="headerlink" title="2.4 概率和"></a>2.4 概率和</h2><ul><li>全概率和 $\sum_{x}P(x) = 1, \int P(x)dx=1$</li><li>偏概率和 $P(x)=\sum_yP(x,y),\int_yP(x,y) = P(x)$</li><li>条件概率  $P(x) = \sum_yP(x|y)P(y), \int_yP(x|y)P(y)$</li><li>条件概率推广 $P(x|y)=\sum_zP(x|z,y)P(z|y),P(x|y)=\int_zP(x|z,y)P(z|y)dz$</li></ul><h2 id="2-5-Bayes公式"><a href="#2-5-Bayes公式" class="headerlink" title="2.5 Bayes公式"></a>2.5 Bayes公式</h2><script type="math/tex; mode=display">\begin{split}&P(x,y)=P(x|y)P(y)=P(y|x)P(x)\\&P(x|y)=\frac{P(y|x)P(x)}{P(y)}=\frac{P(y|x)P(x)}{\sum_xP(y|x)P(x)}\end{split}</script><ul><li>公式的直观理解：造成结果的原因 = 结果*先验知识/所有结果</li><li>Bayes公式给我们一个方式，让我们根据现有的观测结果和先验知识去推算造成这种可能的原因，也就说根据我们的观测计算目标状态和位置</li></ul><h2 id="2-6-高斯分布"><a href="#2-6-高斯分布" class="headerlink" title="2.6 高斯分布"></a>2.6 高斯分布</h2><script type="math/tex; mode=display">\begin{aligned}&P(x)\thicksim N(\mu,\sigma^2) \thicksim N(\mu,\Sigma)\\&P(x)=\frac1{\sqrt{2\pi}\sigma}e^{-\frac12\frac{(x-\mu)^2}{\sigma^2}}\\&P(\mathbf{x})=\frac{1}{\left(2\pi\right)^{d/2}\left|\Sigma\right|^{1/2}}e^{-\frac{1}{2}\left(\mathbf{x}-\mathbf{\mu}\right)^{t}\Sigma^{-1}\left(\mathbf{x}-\mathbf{\mu}\right)}\end{aligned}</script><ul><li>$\mu$ 为均值，$\sigma^2$ 为方差的高斯分布</li></ul><h1 id="3-概率状态估计"><a href="#3-概率状态估计" class="headerlink" title="3. 概率状态估计"></a>3. 概率状态估计</h1><h2 id="3-1-相关概念"><a href="#3-1-相关概念" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h2><p>状态估计是感知问题（perception）的关键，运动则是根据观测结果所做出的的决定</p><ul><li><strong>Perception = state estimation</strong></li><li><strong>Action        = optimization</strong></li></ul><p>传感器是有噪声的，环境也是动态的，感知是很难得到保证的，而感知中的概率模型，可以通过调整方差量来表示噪声项</p><h2 id="3-2-估计方法"><a href="#3-2-估计方法" class="headerlink" title="3.2 估计方法"></a>3.2 估计方法</h2><p>根据我们以上的介绍，在我们有观测结果（perception）的情况下，如果想知道物体的具体状态，我们需要计算：</p><script type="math/tex; mode=display">p(state|perception)</script><p>根据Bayes公式有：</p><script type="math/tex; mode=display">p(st|per) = \frac{p(per|st)p(st)}{p(per)} = \frac{p(per|st)p(st)}{\sum_{st}p(per|st)p(st)}</script><p>观测Bayes公式，我们发现我们只需要知道$p(per|st)和p(st)$即可，一般来说</p><ul><li>$p(per|st)$ 为传感器给定的常识概率分布</li><li>$p(st)$ 则是根据我们已知情况给出的先验知识</li></ul><p>由此，我们便可以估计当前状态</p><h2 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h2><p>我们拿一个开关门的例子演示一下具体流程</p><p>现在，我们使用传感器观测门的状态</p><p><img src="/pic/state/Untitled2.png" alt="img"></p><ul><li>门只有可能有两种状态开或关，我们一开始也不知道门的状态，那么我们就可以假设为$p(open) = 0.5，p(close)=0.5$，即其开关是等可能的</li><li>而我们传感器的概率分布如下</li></ul><p><img src="/pic/state/Untitled3.png" alt="img"></p><p>那么通过Bayes公式有</p><script type="math/tex; mode=display">p(open|z) = \frac{p(z|open)p(open)}{p(z)}=\frac{p(z|open)p(open)}{p(z|open)p(open)+p(z|close)p(close)}</script><p>如果我们的观测结果 z=1.5，那么 $p(z|open)=0.6, p(z|close)=0.3$</p><p>代入我们已有的结果</p><script type="math/tex; mode=display">p(open|z) = \frac{0.6 * 0.5}{0.6 * 0.5+0.3 * 0.5}=\frac{2}{3}</script><h2 id="3-4-多观测条件下Bayes推广"><a href="#3-4-多观测条件下Bayes推广" class="headerlink" title="3.4 多观测条件下Bayes推广"></a>3.4 多观测条件下Bayes推广</h2><p>通过例子，我们很容易看出在有观测的情况下，我们对门状态的认知有了明显的提升。那么，当我们有更多观测的时候，我们的认知也会进一步提升。</p><p>那么如果我们有观测$z_1,z_2$，我们需要计算</p><script type="math/tex; mode=display">\begin{aligned}p(x|z_1,z_2)=\frac{p(z_2,z_1,x)}{p(z_2,z_1)}&=\frac{p(z_2|x,z_1)p(x,z_1)}{p(z_1,z_2)}\\&=\frac{p(z_2|x,z_1)p(x|z_1)p(z_1)}{p(z_2|z_1)p(z_1)}\\&=\frac{p(z_2|x,z_1)p(x|z_1)}{p(z_2|z_1)}\\&=\frac{p(z_2|x,z_1)p(x|z_1)}{\sum_xp(z_2|x,z_1)p(x|z_1)}\end{aligned}</script><p>如果我们有更多的观测，对公式进一步推广</p><script type="math/tex; mode=display">\begin{aligned}p(x|z_1,...z_n)&=\frac{p(z_n|x,z_1,...,z_{n-1})p(x|z_1,...,z_{n-1})}{p(z_n|z_1,...,z_{n-1})}\\&=\frac{p(z_n|x,z_1,...,z_{n-1})p(x|z_1,...,z_{n-1})}{\sum_xp(z_n|x,z_1,...,z_{n-1})p(x|z_1,...,z_{n-1})}\end{aligned}</script><p>这样的推广会出现问题，我们无法得到 $p(z_n|x,z_1,…,z_{n-1})$概率模型</p><p>然而，在实际情况中，每个观测其实是独立的，也就是说我们可以利用Markov假设</p><script type="math/tex; mode=display">p(x|z_1,...,z_n)=\frac{p(z_n|x)p(x|z_1,...,z_{n-1})}{\sum_xp(z_n|x)p(x|z_1,...,z_{n-1})}</script><p>这样，我们把观测模型进行了统一</p><p>考虑我们之前的例子，有其他观测结果$p(z_2|open)=0.6,p(z_2|close)=0.3$</p><p>代入我们公式</p><script type="math/tex; mode=display">\begin{aligned}p(open|z_2,z_1)&=\frac{p(z_2|open)p(open|z_1)}{p(z_2|open)p(open|z_1)+p(z_2|close)p(close|z_1)}\\&=0.8\end{aligned}</script><h2 id="3-5-运动模型"><a href="#3-5-运动模型" class="headerlink" title="3.5 运动模型"></a>3.5 运动模型</h2><p>运动是根据观测所做出的决定，而因为运动不是完全确定的，会增加状态的不确定性。通俗的讲，我们执行一个操作，其带来的结果是不确定的。</p><p><img src="/pic/state/Untitled4.png" alt="img"></p><p>如，我们执行一个关门的操作，在门开着的情况下，有0.9可能关门，也有0.1没有关上门。</p><p>对此，我们引入运动的表达</p><script type="math/tex; mode=display">P(x|u,x')</script><p>u代表执行u使得$x’$转换到$x$状态</p><p>因此我们对状态转移的计算如下：</p><ul><li>$P(x|u)=\int P(x|u,x’)P(x’)dx’$</li><li>$P(x|u)=\sum P(x|u,x’)P(x’)$</li></ul><p>回到我们的例子，如果我们执行一个关门操作 u</p><script type="math/tex; mode=display">\begin{aligned}p(close|u)&=p(close|u,open)p(open)+p(close|u,close)p(close)\\&=0.92\end{aligned}</script><h1 id="4-Bayes-滤波"><a href="#4-Bayes-滤波" class="headerlink" title="4. Bayes 滤波"></a>4. Bayes 滤波</h1><p>有了上述的概率状态估计方法，我们以此使用观测和运动进行更新状态即可，那么Bayes滤波方法也就呼之欲出了。</p><p>我们有</p><ul><li>我们有一组观测和运动 $d_t=\{u_1,z_1,…,u_t,z_t\}$</li><li>观测模型 $P(z|x)$</li><li>运动模型 $P(x|u,x’)$</li><li>初始的先验状态 $P(x)$</li></ul><p>想知道</p><ul><li>状态概率 $Bel(x_t)=P(x_t|u_1,z_1,…,u_t,z_t)$</li></ul><p>和之前类似，我们也采用Markov假设</p><ul><li>运动后预测状态 $p(z_t | x_{t-1}, u_t )$</li><li>观测后估计状态 $p(z_t|x)$</li></ul><p>由此，我们得出Bayes滤波的基本公式</p><ul><li>运动后预测状态 $\begin{aligned}\overline{bel}(x_t) = \int p(x_t|u_t,x_{t-1})bel(x_{t-1})dx_{t-1}\end{aligned}$</li><li>观测后估计状态 $bel(x_t) = \eta p(z_t|x_t)\overline{bel}(x_t)$</li></ul><p>进一步，当我们的观测为多个时，假设其相互独立</p><script type="math/tex; mode=display">\begin{aligned}&p_1^t(z_1^t|x),p_2^t(z_2|x),...,p_k^t(z_k^t|x)\\&p(z_1,z_2,...,z_k|x)=\frac{p(z_1|x)p(_2|x)\cdots p(z_k|x)}{\sum p(z_1|x)p(z_2|x)\cdots p(z_k|x)}\\&bel(x_t) = \eta p(z_1,z_2,...,z_k|x)\overline{bel}(x_t)\end{aligned}</script><p>同样的，当我们状态转移也有多种时，状态转移图就就无法统一的进行描述，因此我们使用状态转移矩阵的方式。如图所示，对于四种运动我们有四个状态转移矩阵，矩阵中的元素代表在此操作下，两个状态转移的概率。</p><p><img src="/pic/state/Untitled5.png" alt="img"></p><h1 id="5-Kalman-滤波"><a href="#5-Kalman-滤波" class="headerlink" title="5. Kalman 滤波"></a>5. Kalman 滤波</h1><p>从Bayes滤波我们可以看出，其核心在于得到传感器的概率分布，然而有时候传感器的概率分布我们无从得知，或者无法用确定的函数表示，那么这个时候我们应该如何做呢？从我们日常经验来看，一般这个时候我们都会去寻求近似，那么如何利用已知的情况去近似呢？</p><p>我们不免想起我们的概率中老朋友<strong>高斯分布</strong>，当我们使用高斯分布去作为我们传感器的概率分布时，我们就得到了Kalman 滤波。</p><p>我们有</p><ul><li>$p(x)\thicksim N(\mu,\sigma^2)\thicksim N(\mu,\Sigma)$</li><li>因为高斯分布的运算封闭，因此我们只需要运算高斯分布的均值和方差即可</li></ul><p>那么</p><ul><li>$p(x_t|u_t,x_{t-1})\Rightarrow {x_t=A_tx_{t-1}+B_tu_t+\mathcal{E}_t}$<ul><li>$\mu=A_{t}x_{t-1}+B_{t}u_{t}$</li><li>$\varepsilon_t\sim N(0,\sigma_{\varepsilon_t}^2)$</li></ul></li><li>$p(z_t|x_t)\Rightarrow \begin{aligned}z_t=H_tx_t+\delta_t\end{aligned}$<ul><li>$\mu=H_{t}x_{t}$</li><li>$\delta_t\sim N(0,\sigma_{\delta_t}^2)$</li></ul></li></ul><p>其中</p><ul><li>$A_t$ 状态转移矩阵：没有控制和噪声的情况下的状态转移矩阵 <em>n</em>n*</li><li>$B_t$ 输入矩阵：描述 $\mu_t$ <em>*如何影响状态变化 </em>n<em>l</em></li><li>$H_t$ 观测矩阵：<em>k</em>n*，$z_t$和$x_t$之间的关系</li><li>$\varepsilon_t$   过程噪声：其方差矩阵为 $R_t$ <em>*，</em>n<em>n</em></li><li>$\delta_t$   观测噪声：其方差矩阵为 $Q_t$，<em>k</em>k*</li></ul><p>得到Kalman 滤波的方法</p><ul><li>运动预测<ul><li>基于转移和控制预测 $\overline{\mu}_t=A_t\mu_{t-1}+B_tu_t$</li><li>预测方差 $\overline{P}_t=A_tP_{t-1}A_t^T+R_t$</li></ul></li><li>观测修正<ul><li>Kalman 增益 $K_t=\overline{P}_tH_t^T(H_t\overline{P}_tH_t^T+Q_t)^{-1}$</li><li>状态更新 $\mu_t=\overline{\mu}_t+K_t\boxed{(z_t-H_t\overline{\mu}_t)}(Innovation \ provided\ by\ z_t)$</li><li>方差更新 $P_t=(I-K_tH_t)\overline{P_t}$</li></ul></li></ul><h1 id="6-扩展Kalman-滤波（EKF）"><a href="#6-扩展Kalman-滤波（EKF）" class="headerlink" title="6. 扩展Kalman 滤波（EKF）"></a>6. 扩展Kalman 滤波（EKF）</h1><p>我们从Kalman 滤波的公式中可以发现，其中包含着很强的线性假设，其对于线性系统的滤波是最优的。但是，绝多数现实中的系统都不是线性的，那么我们应该如何去近似呢？</p><p>有非线性到线性的转换，我们最熟悉的莫过于泰勒公式了，利用泰勒公式的一阶近似，我们就得到了EKF的基本原理。</p><ul><li>转移</li></ul><script type="math/tex; mode=display">\begin{aligned}& \overline{x}_t=g(u_t,x_{t-1})\approx g(u_t,\mu_{t-1})+\frac{\partial g(u_t,\mu_{t-1})}{\partial x_{t-1}}(x_{t-1}-\mu_{t-1})(Taylor)\\&\overline{x}_t=g(u_t,x_{t-1})\approx g(u_t,\mu_{t-1})+G_t\left(x_{t-1}-\mu_{t-1}\right)(Jaccobi)\end{aligned}</script><ul><li>观测</li></ul><script type="math/tex; mode=display">\begin{aligned}&h(x_t)\approx h(\overline{\mu}_t)+\frac{\partial h(\overline{\mu}_t)}{\partial x_t}(x_t-\overline{\mu}_t)\\&h(x_t)\approx h(\overline{\mu}_t)+H_t\left(x_t-\overline{\mu}_t\right)\end{aligned}</script><p>得到EKF 方法</p><ul><li>预测<ul><li>$ \mu_{t}=g(u_t,\mu_{t-1})$</li><li>$ \overline{P}_t=G_tP_{t-1}G_t^T+R_t$</li></ul></li><li>修正<ul><li>$K_t=\overline{P}_tH_t^T(H_t\overline{P}_tH_t^T+Q_t)^{-1}$</li><li>$\mu_{t}=\overline{\mu}_{t}+K_{t}(z_{t}-h(\overline{\mu}_{t}))$</li><li>$P_{t}=(I-K_{t}H_{t})\overline{P}_{t}$</li></ul></li><li>其中<ul><li>$H_t=\frac{\partial h(\overline{\mu}_t)}{\partial x_t}\quad$</li><li>$G_t=\frac{\partial g(u_t,\mu_{t-1})}{\partial x_{t-1}}$</li></ul></li></ul><h1 id="7-无迹卡尔曼滤波（UKF）"><a href="#7-无迹卡尔曼滤波（UKF）" class="headerlink" title="7. 无迹卡尔曼滤波（UKF）"></a>7. 无迹卡尔曼滤波（UKF）</h1><p>和之前一样，在考虑EKF 时我们也会问一阶近似是否足够，如果不够那么我们应该怎么办？</p><p>考虑概率论的方法，一个曲线的除了由它本身、导数所描述，也有其构成点所描述，那么我们只需要进行特定的采样，就可以对系统状态的概率分布进行近似，这就是UKF。</p><p>UKF的算法包括以下几个步骤：</p><ol><li>选择Sigma点：根据系统状态的均值和协方差矩阵，使用无迹变换的方法选择一组Sigma点。这些Sigma点包括系统状态的均值点和由均值和协方差矩阵计算得到的一些偏差点。</li><li>预测步骤：对每个Sigma点进行系统状态的预测。通过应用系统动态模型，将每个Sigma点转换为预测状态。</li><li>估计预测均值和协方差：根据预测的Sigma点，计算预测状态的均值和协方差。这些预测值将用作测量更新步骤的先验估计。</li><li>测量更新步骤：对每个预测状态进行测量更新。通过应用测量模型，将每个预测状态转换为测量空间中的估计值。</li><li>估计测量均值和协方差：根据测量更新的估计值，计算测量状态的均值和协方差。</li><li>计算卡尔曼增益：使用预测和测量的均值和协方差，计算卡尔曼增益，用于融合预测和测量的信息。</li><li>更新状态估计：根据卡尔曼增益，将预测状态和测量状态进行加权融合，得到最终的系统状态估计。</li></ol><p>UKF的具体计算方法比较复杂，感兴趣的读者可以自行查阅。</p><h1 id="8-粒子滤波"><a href="#8-粒子滤波" class="headerlink" title="8. 粒子滤波"></a>8. 粒子滤波</h1><p>粒子滤波（Particle Filter）是一种基于蒙特卡洛方法的概率状态估计技术，用于非线性和非高斯系统的状态估计。粒子滤波通过使用一组粒子来逼近系统状态的后验概率分布，并根据系统动态模型和测量信息进行更新。</p><p>粒子滤波的基本思想是通过在状态空间中随机采样一组粒子，每个粒子表示系统可能的状态。这些粒子的权重根据预测模型和测量模型进行更新，从而反映了它们与实际状态的拟合程度。在每个时间步骤中，粒子滤波通过对粒子进行重采样和更新，逐渐逼近系统的后验概率分布。</p><p>下面是粒子滤波的详细步骤：</p><ol><li>初始化：根据先验知识或初始测量值，生成一组随机的粒子，并为每个粒子分配相同的权重。</li><li>预测步骤：通过应用系统动态模型，对每个粒子进行状态的预测。可以通过从先前状态中采样，并根据系统动态模型添加随机噪声来实现。</li><li>权重更新：根据测量模型，计算每个粒子的权重。权重表示了粒子与实际测量值的拟合程度。拟合程度较好的粒子将获得较高的权重，而拟合程度较差的粒子将获得较低的权重。</li><li>标准化权重：对所有粒子的权重进行标准化，使它们之和等于1。这样确保了权重表示概率分布。</li><li>重采样：根据粒子的权重，进行重采样操作。较高权重的粒子将以较高的概率被选中，而较低权重的粒子将以较低的概率被选中。通过重采样操作，粒子集合中的粒子数目会趋于稳定，以更好地表示后验概率分布。</li><li>状态估计：根据重采样后的粒子集合，可以通过计算粒子的加权平均值或加权中位数来获得对系统状态的估计。</li></ol><p>重复执行上述步骤，粒子滤波可以逐步逼近系统的后验概率分布，并提供对系统状态的估计。</p><p>感兴趣的读者可以继续深入了解。</p><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>本文，从日常生活的经验出发，尝试梳理滤波类方法的发展过程。滤波类状态估计方法包括Kalman滤波、扩展Kalman滤波（EKF）、无迹卡尔曼滤波（UKF）和粒子滤波。这些方法都是用于非线性系统状态估计的重要工具，主要详细介绍了Kalman 滤波和扩展Kalman滤波（EKF）。</p><p>首先是Kalman滤波，它是一种基于高斯分布的状态估计方法。Kalman滤波使用线性模型和高斯分布来近似系统的状态和测量噪声。它通过运动预测和观测修正两个步骤来更新状态估计和方差估计。</p><p>接下来是扩展Kalman滤波（EKF），它是对Kalman滤波的非线性扩展。EKF使用泰勒公式对非线性系统进行线性近似，从而使得Kalman滤波方法也适用于非线性系统。通过对状态转移和观测模型进行线性化，EKF能够在非线性系统中进行状态估计。</p><p>然后是无迹卡尔曼滤波（UKF），它是对EKF的改进。UKF使用无迹变换的方法选择一组Sigma点来近似系统状态的分布。通过对这些Sigma点进行预测和测量更新，UKF能够更准确地估计非线性系统的状态。</p><p>最后是粒子滤波，它是一种基于蒙特卡洛方法的概率状态估计技术。粒子滤波通过使用一组粒子来逼近系统状态的后验概率分布，并根据系统动态模型和测量信息进行更新。通过对粒子的重采样和更新，粒子滤波能够逐步逼近系统的后验概率分布，提供对系统状态的估计。</p><p>总而言之，这些滤波类状态估计方法在非线性和非高斯系统的状态估计中发挥重要作用。它们通过不同的近似和采样方法，能够有效地对系统状态进行估计，并提供准确的预测和修正。这些方法在估计和控制领域有广泛的应用，可以用于机器人导航、目标跟踪、信号处理等多个领域。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>幻梦</title>
      <link href="/2022/07/18/%E5%B9%BB%E6%A2%A6/"/>
      <url>/2022/07/18/%E5%B9%BB%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<pre><code>The world has kissed my soul with its pain, asking for its return in songs.</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English Listening 179</title>
      <link href="/2022/06/26/English-Listening-179/"/>
      <url>/2022/06/26/English-Listening-179/</url>
      
        <content type="html"><![CDATA[<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><pre><code>learning from Mr Liu, I know some important word in English Listening Test, IETS.I think it&#39;s very useful, so I try to make a note to familiar myself with these words.All words come from the book by the teacher, Liu Hongbo.</code></pre><h3 id="theme-different"><a href="#theme-different" class="headerlink" title="theme: different"></a>theme: different</h3><p>adjust, change, alter, modify, shift, revert</p><p>diversity, a variety of, a number of, a range of, various, different</p><p>transfer, move, relocate(搬迁，迁移)</p><p>emigrate, move, go away</p><p>similar, like , compare</p><p>particular, special ,in particular, especially</p><p>copy, repeat, reproduce</p><p>annual, every year</p><p>every month, monthly, four weeks</p><p>every day, daily</p><p>shape like, look like, seem</p><p>repetition, over and over</p><h3 id="theme-logic"><a href="#theme-logic" class="headerlink" title="theme: logic"></a>theme: logic</h3><p>and, also, as well as, with, in addition</p><p>but, however, yet, instead</p><p>because, why, as a result, therefore, cause</p><p>result, outcome, consequence, conclusion</p><p>maximum, up to, at most</p><p>minimum, at least</p><p>initial, at first, start, begin, early on, premiere</p><p>limited, just a few, a little, small, a small number of, not many,miniature</p><p>shorten, cut down</p><p>decrease, lower, reduce, fewer, drop, fall, decrease</p><p>lack, shortage, insufficient, fewer, not enough</p><p>large, big, huge</p><p>amount of, lots of, large quantities of, loads of</p><p>marjority, most</p><p>double, twice</p><p>more than, over, beyond, exceed, above</p><p>classify, category, sort, type, kind</p><p>behind, back, rear</p><p>below, under</p><p>beside, next to, near, border</p><p>specific, detail, particular, example</p><p>climb, go up, increase</p><p>enhance, improve, increase</p><p>preference, like, priority</p><p>turn, switch</p><p>continue, ahead, go on, keep doing</p><h3 id="theme-service"><a href="#theme-service" class="headerlink" title="theme: service"></a>theme: service</h3><p>fee, money, cost, price, expense, budget, fund, financial, economic</p><p>hospitality, treatment, prepare refreshment</p><h3 id="theme-nature"><a href="#theme-nature" class="headerlink" title="theme: nature"></a>theme: nature</h3><p>habitat, live, territory(领土，版图，领地)</p><p>vegetation, plant, tree, forest, botanic(植物的；植物学的)</p><p>animal, mamal, wildlife, creature, species</p><h3 id="theme-civilization"><a href="#theme-civilization" class="headerlink" title="theme: civilization"></a>theme: civilization</h3><p>international, countries, continents, global</p><p>export, abroad, overseas</p><p>at present, already, existing, currently, nowadays</p><p>update, upgrade, up to date, more current, modern</p><p>newest, latest</p><p>soon, later, in the future</p><p>out of date, old fashioned</p><p>ancient, medieval, in the past, once, historical, old, former</p><p>temporary, a short time</p><p>deadline, time pressure, on time</p><p>permanent, long-lasting</p><p>military, battle, weapon, not peaceful</p><h3 id="theme-person"><a href="#theme-person" class="headerlink" title="theme: person"></a>theme: person</h3><p>feature, characteristic, trait, property</p><p>food, feed on, eat</p><p>allergic, can’t eat</p><p>fitness, health, medical, sickness, illness, gym</p><p>advantage, benefit, positive, good thing, strength</p><p>disadvantage, drawback, shortcoming, negative, problem</p><p>ordinary people, people, inhabitants, the public, men and women</p><p>purpose, aim, goal, target, key areas</p><p>expertise, ability, skill</p><p>group, team</p><p>motivate, encourage, stimulate, keep active, boost, help</p><p>improve, develop. promote</p><p>overlook, underestimate, neglect</p><p>prevent, avoid, stop, escape, forbid, out of bounds</p><p>misunderstand, wrong idea, confuse, puzzle, perplex</p><p>try hard, make efforts, hard working</p><p>affect, impact, influence, effect</p><p>support, help, assistance, aid, tip</p><p>ideal, perfect</p><p>care, caution</p><p>steal, theft</p><p>protect, safeguard, shelter, perserve</p><p>injury, harm, hurt, damage, dangerous, frighten</p><p>rely on, depend on, count on</p><p>request, ask for, inquriy</p><p>all ages, young and old</p><p>youth, young, boy, child, teenager</p><p>alone, single, by themseleves</p><p>depress, disappoint, disprint, frustrate, discourage</p><h3 id="theme-somethings"><a href="#theme-somethings" class="headerlink" title="theme: somethings"></a>theme: somethings</h3><p>traditon, custom, convention, local culture, lifestyle</p><p>associate, relate to, connect, link</p><p>reserve, book</p><p>in advance, ahead, before</p><p>have to, must, should, need, require, necessary, be supposed to, demand, order</p><p>approach, way, how, method</p><p>opportunity, chance, odds, hope</p><p>difficult, problem, hard, not easy, not simple</p><p>feedback, response, reaction, reply</p><p>handle, deal with, cope with, figure out, work out, take care of</p><p>rigorous, strict, demanding</p><p>risky, dangerous, not safe, hazard</p><p>tactics, strategy, method</p><p>renovate, fix, repair</p><p>part, component, proportion, percent, seciton, element, ingredient(成分，原料；要素，因素)</p><p>demonstrate, display, show, exhibition</p><p>important, siginificant, major, main, primary</p><p>disused, empty, abandoned</p><p>visualize, imagine</p><h3 id="theme-social"><a href="#theme-social" class="headerlink" title="theme: social"></a>theme: social</h3><p>press. media, TV, newspaper, radio</p><p>online, internet, website</p><p>publicity, website, media, news, marketing</p><p>organization, business, company, corporation, structure</p><p>organize, arrange, plan</p><p>produce, generate, make</p><p>administer, manage</p><p>occupation, profession, job</p><p>mate, staff, recruit, worker, employee</p><p>sale, retail</p><p>order, sequence</p><p>well-known, famous, fame</p><p>trust, less suspicious, believe</p><p>donate, charity, give</p><p>information, details, data, graph, chart</p><h3 id="theme-hobby"><a href="#theme-hobby" class="headerlink" title="theme: hobby"></a>theme: hobby</h3><p>entertainment, recreation(娱乐（活动），消遣（活动）；重现，重建), leisure</p><p>picture, photo, photograph, camera, image</p><p>jewelley, rings, bracelets(bracelet), necklaces, precious stones, gem, diamond, luxuious</p><p>artwork, painting, drawing, craft</p><p>statue, sculpture, carving</p><p>movie, film, documentary, cinema</p><p>boring, not interesting, boredom</p><p>trend, possibility, likely, tendency</p><p>travel, tourism, trip, passenger, flight</p><p>space travel, aricraft, rocket, satellite</p><p>specialize in, focus, emphasis, concentrate</p><p>computer, laptop</p><p>handy, convenient</p><h3 id="theme-place"><a href="#theme-place" class="headerlink" title="theme: place"></a>theme: place</h3><p>geology, cliff, fossil, rock, landscape</p><p>country, rural area</p><p>urban, city, metropolitan(大都市的；本土的)</p><p>coastline, shore, seaside</p><p>environment, neighbourhood, surrounding</p><p>noisy, disturbing, not quiet</p><p>outdoor, gardens, park, open air</p><p>accommodation, living, dwelling(住宅，住所，公寓), dorm</p><p>place, where, spot, location, area</p><p>near, close, not far from, nearby</p><p>remote, isolated, distant</p><p>entrance, access, main gate, door</p><p>transport, vehicle, bus, train, boat, ship, ferry, subway</p><p>expand, add, enlarge, increase spaces</p><p>refurbish, redecorate(重新装饰)</p><p>pollutant, contaminant</p><h3 id="theme-stuff"><a href="#theme-stuff" class="headerlink" title="theme: stuff"></a>theme: stuff</h3><p>capacity, volume, room, space, size</p><p>structure, outline, framework</p><p>extensive, comprehensive, a lot of, many</p><p>omit, leave out, cancel</p><p>find, discover, detect, spot, see, sight</p><p>restrict, limit, not permit</p><p>available, have, accessible, not close, open</p><p>poisonous, toxic, dangerous</p><p>warning, alarm, alert</p><p>clear, definitive</p><p>freeze, froze, ice, chill, cold</p><p>cheep, low price</p><p>discount, 10% off, on sale</p><p>round, curve, circle</p><p>typical, representative, common, average</p><p>uncommon, special, unique, unusual, rare</p><p>accurately, precisely</p><p>power, force, energy</p><p>fuel, coal, firewood, pertrol, gas</p><p>straightforward, direct, first-hand, simple</p><p>poor, weak</p><p>durable, stronger, longer</p><h3 id="theme-education"><a href="#theme-education" class="headerlink" title="theme: education"></a>theme: education</h3><p>education, schools, colleges, institution</p><p>student, pupil, undergraduate, postgraduate</p><p>learn, acquire, get, obtain</p><p>reference materials, books, journals, magazines</p><p>analysis, perspective, understand, perceive, know</p><p>statistics, data, figure</p><p>work, item</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/24/hello-world/"/>
      <url>/2022/03/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
